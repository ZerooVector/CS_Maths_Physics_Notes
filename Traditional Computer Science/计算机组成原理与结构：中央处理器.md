#TraditionalComputerScience 
### CPU 的基本组成
CPU 的功能：指令控制、操作控制、时间控制、数据加工、中断处理等等。总结来说，就是控制信号的产生（以及顺序和时序）、算术逻辑运算
CPU 的组成：数据通路（指令的执行部件，例如运算器和执行器）、控制器（指令的控制部件）
其中，运算器包括：ALU、暂存寄存器、ACC、通用寄存器组（包括栈顶指针 SP）、状态寄存器（OF、SF、ZF、CF）、移位器、计数器等等
控制器包括：PC（程序计数器）、IR（指令寄存器）、ID（指令译码器：用于将操作码翻译出来，知道这是一条什么指令）、MAR、MDR、时序系统（脉冲源、启停控制逻辑、节拍信号发生器）、微操作信号发生器、地址形成部件、中断控制逻辑等等
控制器中的微操作可以使用硬件实现，也可以使用微程序实现

CPU 中的指令部件：PC、IR、ID、地址形成部件（根据不同寻址方式，生成操作数的有效地址）；时序部件：脉冲源、启停控制逻辑（开放或者封锁脉冲）、节拍信号发生器；此外，还包括微操作信号发生器 (CU)、中断控制逻辑


### 指令周期
一个指令周期可以包含多个机器周期（FEtch, INDirect, EXecute, INTerrupt），一个机器周期又可以包含多个节拍（也就是时钟周期），定出机器周期可以有统一节拍法（以最复杂的微操作作为标准，定出节拍）、分散节拍法（需要几个节拍就发出几个，各个机器周期长度不同）、延长节拍法（每个节拍可以不一样长）。在一个节拍内通常需要设置多个工作脉冲，用来同步各项操作。所以我们会有三级时序。
![[Pasted image 20231031204816.png|400]]
CPU 可以采用同步控制方式（各部件所需时序信号由控制器统一发出）、异步控制方式（各个功能部件产生时序信号自我控制）、联合控制（功能部件内部同步，之间异步）方式三种。

#### CPU 的工作流程（重点）
CPU 可以使用组合逻辑法实现，也可以使用存储逻辑法实现。在本文中，我们重点介绍存储逻辑法。
CPU 的工作流程如下：
- 取指阶段：PC ->MAR  CU: Read  M (MAR) ->MDR MDR->IR (PC)+1 ->PC 
- 间址阶段：Ad (IR) -> MAR  CU: Read M (MAR) ->MDR MDR ->IR 
- 执行周期：自己写，没有确定的执行方法
总之，在发出“读”信号后，MAR 地址其中的东西就会被拿到 MDR 里面。在发出“写”信号后，MDR 中的东西就被写到 MAR 所指的地址上。

### 微程序控制
微程序控制器涉及的两个层次 一个是机器语言或汇编语言程序员所看到的传统机器层，包括：机 器指令、工作程序、主存储器；另一个是机器设计者看到的微程序层 ，包括：微指令、微程序和控制存储器。
微命令是微操作的控制信号、微操作是微命令的执行过程。二者一一对应。
微指令和正常的指令一样，是控制存储器中一个单元的内容，是若干个微命令的几何。存放地址就称为微地址。
一条机器指令就对应一个微程序。微程序是微指令的有序集合。

和真实的指令一样，一条微指令中需要包括：操作控制字段（产生微操作控制信号）和顺序控制字段（产生下一条微指令的地址）

微指令的编码方法有两种：直接控制法（操作控制字段中的每一位直接对应一个微命令是否被执行。操作简单可并行，但是太长了，而且许多微指令是互斥的，放在一起没有意义）；最短编码法（译码电路太复杂）、字段直接编码法（各个字段可以独立地定义自己的微命令）、字段间接编码法（一个字段需要与其他字段联合使用）

**把互斥性的微命令分在同一段内，兼容性的微命令分在不同段内。这样不仅有助于提高信息的利用率，缩短微指令字长，而且有助于充分利用硬件所具有的并行性，加快执行的速度**。应与数据通路结构相适应。每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间。**一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此当某字段的长度为三位时，最多只能表示七个互斥的微命令，通常用000表示不操作**

### 微程序的执行过程
四个部件：控制存储器 CM、微指令寄存器 uIR、微地址形成部件、微地址寄存器 uMAR 
CPU 如何控制机器指令的执行过程：
- 取指令公共操作：将取指微程序入口地址送入 uMAR，从 CM 中读出相应微指令送入 uIR。此时产生微命令，控制取机器指令的公共操作。当这个取指微程序执行完成后，机器指令就存入指令寄存器 IR 中。（也就是说取指过程实际上是全自动的！）
- 由机器指令的操作码字段产生该机器指令对应的微程序的入口地址，送入 uMAR（这个过程是由**微**地址形成部件完成的）
- 从 CM 中逐条读取微指令并执行
- 此后程序又回到取指微程序的入口地址，从而周而复始执行


入口地址的产生：
- 一级功能转换：如果机器指令操作码字段的位数和位置固定，可以直接使操作码与入口地址码的部分位相对应
- 二级功能转换：所谓二级功能转换是指第一次先按指令类型标志转移，以区分出指令属于哪一类，如：是单操作数指令，还是双操作数指令等。因为每一类机器指令中操作码字段的位数和位置是固定的，所以第二次即可按操作码区分出具体是哪条指令
- PLA 电路：当机器指令的操作码位数和位置都不固定时，可以采用 PLA 电路将每条机器指令的操作码翻译成对应的微程序入口地址

后继微地址形成：
- 增量方式（顺序、转移、转子）。顺序执行时后继微地址就是现行微地址加上一个 增量（通常为1）；转移或转子时，由微指令的顺序控制字段产生转移微地址
- 断定方式：后继地址通常分为非测试段和测试段，其中非测试段直接指定，测试段由目前的状态指定

水平型微指令（定义几种并行的基本操作）、垂直型微指令（控制一、二个信息传送通路，效率低，一条指令只能实现一个微操作，执行一条机器指令所需的微指令数目多）

### 流水线
- 时间上的并行技术、空间上的并行技术
- 流水线的每一段被称为一个流水周期，流水线周期等于时间最长的流水段的时间长度，每个流水线周期输出一个任务结果
- 流水线的关键技术是处理不平衡流水段，一是“瓶颈”部分再细分，另一种是“瓶颈”段复制
- 流水线中存在结构冒险（硬件冲突）、数据冒险（一条指令依赖的结果没有准备好）

流水线的评价指标：
- 吞吐量：单位时间从流水线流出的指令数
- 流水线的加速比：使用流水线的时间/不使用流水线的时间

#### 各种奇怪的错误
![[69bb208478a803e6cbeb42c8a14f8a9.jpg]]
死因 ：对于 A，显然硬件最快；对于 B，ROM；对于 C，请你睁开眼看看

![[11b98b79fcb47b2069ae17405090d47.jpg]]
死因：转移指令会直接修改 PC，但是指令并不会（直接）根据转移指令从主存中读出

![[aee15177cdfe3be7ae99ea710a7b7b8.jpg]]
死因：指令字长通常是机器字长的整数倍，但是二者之间确实没有什么必然联系。如果指令字长等于存储字长，那么想要取到指令，只需要访存一次，那么取指周期就等于机器周期了

![[cef71abe15b974b52c01882efb6624c.jpg]]
死因：主要想说的是，如果你使用了单总线，而且 CPI=1，那么 ALU 这种需要两个不同输入的元件该怎么办呢？

![[1c0046e8c3b71a0892bdc2c12df0874.jpg]]
死因：可以看的包括 PC、通用寄存器、标志状态寄存器、基址寄存器、变址寄存器

![[f4de1173ae2610d7d53b4343f039e88.jpg]]
这个要注意的是，每个指令的微程序中那 4 条不包含取指。取指是一个单独的微程序。








