#TraditionalComputerScience 
### 机器指令的基本格式
定长指令字结构、变长指令字结构；指令长度应该尽可能短且等于字节的整数倍

机器指令需要包含：两个操作数的地址、结果存放地址、下条指令的地址。机器指令的基本格式包括以下几种：
- 四地址指令：四个都给
- 三地址指令：下一条指令地址默认在 PC+1
- 二地址指令：给出的两个地址是源操作数地址和目的地址
- 一地址指令：只有一个操作数。结果存回原地址
- 零地址指令：操作数是隐含的，或者是停机、关中断、空指令
从缩短程序长度，用户使用方便，增加操作并行度等方面来看，选用三地址指令格式较好；从缩短指令长度，减少访存次数，简化硬件设计等方面来看，一地址指令格式较好。对于同一个问题，用三地址指令编写的程序最短，但指令长度最长，而用二、一、零地址指令来编写程序，程序的长度一个比一个长，但指令的长度一个比一个短

### 指令的操作码
定长操作码指令格式：$N \ge \log_{2}m$
变长操作码指令格式：最常见的是扩展操作码法（可以考大题，需要灵活处理）
![[Pasted image 20231031012544.png|450]]
如果需要对操作码的编码方式进行优化，那么需要使用 Hufman 树：每次选择概率最小的两个节点合并

### 编址与寻址
一般来说我们有按字编址、按字节编址两种方法；早期的机器是按字编址的，现在基本上是按字节编址。编制单位不等于访问单位，一般来说，访问单位都是编制单位的若干倍

注意：地址码与主存容量和编址方式有关系！每个编址单位所包含的信息量（二进制位数）与读或写一次寄存器、 主存所获得的信息量是相同的。字节编址是为了适应非数值计算的需要。通常主存的访问单位是编址单位的若干倍。

我们有两种寻址：数据寻址、指令寻址。指令寻址简单，要么使用顺序寻址，每一次 PC +1；要么使用跳跃寻址。数据寻址比较难。
一般来说，我们使用 $A$ 表示一个数，而使用 $(A)$ 表示这个地址中存放的数
- 隐含寻址：地址并不会显式给出，而是（默认地）被存放在某一元件中
- 立即寻址：指令里面就有操作数
- 直接寻址
- 间接寻址
- 寄存器寻址、寄存器间接寻址
- 相对寻址：PC 中的值加上指令中的形式地址 ,**注意 PC 需要自增** 
- 基址寻址、变址寻址（基址寄存器中的值不能动，但是变址寄存器中的值可以动，可正可负）
变址寻址是面向用户的，用于访问字符串、向量和数组等成批数据；而基址寻址面向系统，主要用于逻辑地址和物理地址的变换，用以解决程序在主存中的再定位和扩大寻址空间等问题。在某些大型机中，基址寄存器只能由特权指令来管理，用户指令无权操作和修改
- 页面寻址：零页面寻址、当前页寻址、页面寄存器寻址
寻址速度排序：• 立即寻址 • 寄存器寻址 • 直接寻址 • 寄存器间接寻址 • 页面寻址 • 变址寻址（基址寻址、相对寻址） • 一级间接寻址 • 多级间接寻址
一条指令中的多个地址可以分别采用不同的寻址方式
![[f26a80649a86eea237c42310f02c519.jpg]]


### 堆栈操作
- 硬堆栈：寄存器构成，可以自行推移数据
- 软堆栈：需要栈顶指针。入栈是 $(SP)-1 \rightarrow SP, (A) \rightarrow (SP)$，出栈相反：$(SP) \rightarrow (A), (SP)+1 \rightarrow (SP)$。注意：这两个顺序是反的
 
### 汇编指令
- 数据传送
	- 传送：MOV 用法：MOV mem 1 mem 2 或者 MOV reg 1 reg 2
	- 堆栈操作：PUSH 和 PULL
	- 数据交换
- 运算
	- 算术运算
	- 逻辑运算
	- 移位
- 程序控制
	- 转移 JMP（无条件转移）
	- 子程序调用（一地址指令）：CALL RET 可以使用堆栈来保存返回地址，也有其他方法，例如使用子程序的第一个字单元中（注意：这样我们就不能递归了），或者存在寄存器中，再由子程序转移到某个安全的地方
	- 转移指令转移到指令中给出的转移地址处执行指令，不存在返回 要求，没有返回地址问题；而子程序调用指令必须以某种方式保存返回 地址，以便返回时能找到原来的位置。 • 转移指令用于实现同一程序内的转移；而子程序调用指令转去执 行一段子程序，实现的是程序与程序之间的转移。
- 输入、输出指令：输入输出独立编址的计算机中才有，否则用 MOVE

### 指令系统的发展
复杂指令、精简指令计算机
![[13f1312a43368499304d990d07edab3.jpg]]
![[6f15714e21119ce25193cb55acb8a24.jpg]]
![[0cf0bdc031965666ab0e6808ff935a9.jpg]]

#### 各种奇奇怪怪的错误
![[52b50c7df94bb7e3187e3113ce91c07.jpg]]
死因：指令和机器底层的东西都有关系。建议记住

![[9375a0545fd75c93dd80fa2008a4d17.jpg]]
死因：堆栈计算机

![[0f92efa40a07fbf0416927e4f8f1b2f.jpg]]
死因：几地址指令其实和长度没有必然的关系（e.g.操作数的长度是可变的）。但是记住**单字长指令可以加快取指速度** 

![[d607cf705ef50f3e080d146fdf03dd1.jpg]]
死因：程序需要在内存中“浮动”，因此，我们必须找相对地址。

- 为了减小指令的长度，我们可以采取寄存器寻址。这是因为寄存器的数目少。为了减小指令的复杂程度，我们可以使用零地址指令。

![[12090c4f821671d765e6bce9701f5d9.jpg]]
- 死因：看好“有效内容”和“有效地址”的区别

![[55469d67df73f5c602e8f6d4ec2d8c2.jpg]]
解法：算出可以容纳偏移量的地方有 16 位，就做完了

![[7843deea69aa6210189bd8dff133b43.jpg]]
解法：这个题目是比较难的。你首先需要知道，由于主存地址不能为负，因此基址寄存器中的数一定是无符号数，然后，形式地址是一个补码。算完以后由于题目中说是"大段方式"，那么低位会放在地址较高处。容易选出最后的结果。

- RISC 机一定会使用流水技术，但是使用流水技术的不一定是 RISC 机
- RISC 是试图弱化每条指令的功能的
- RISC 的指令**不是**从 CISC 中挑选了一部分实现的，更没有使得计算机体系结构倒退

![[bfa3ba4df17a5151201d995f1fe6442.jpg]]
记一下记一下

