#TraditionalComputerScience 
## 进程与线程

### 关于进程

进程引入的目的是更好地描述与控制程序的并发执行。每个进程有一个 PCB，程序段、相关数据段、PCB 三部分构成了进程实体。PCB 是进程存在的唯一标志。进程具有动态性、并发性、独立性、异步性的特征。

进程有 3 个（5 个）状态：
![[68b21e8f8d7320bdb6d7a15003c7a85.jpg]]
- 就绪->运行：处于就绪态的进程被调度后，获得处理机资源
- 运行->就绪：处于运行态的进程在时间片用完后出让处理机
- 运行->阻塞：请求某一资源的使用和分配，或者等待某一事件的发生
- 阻塞->就绪：进程等待的事件到来

进程的组织：
- PCB：进程描述信息（进程标识符和用户标识符）、进程控制和管理信息（进程当前状态和优先级）、资源分配清单、处理机相关信息
- 程序段
- 数据段

进程的控制：
- 进程的创建：用户登陆系统、作业调度、系统提供服务等待。创建原语：分配进程标识号、所需的资源、初始化 PCB、若就绪队列可以接纳新进程，则将新进程插入就绪队列
- 进程的终止：正常结束、异常结束、外界干预等待。终止原语：终止进程运行、终止子孙进程运行、归还资源给操作系统或者父进程、删除 PCB 
- 进程的阻塞：保护现场、转为阻塞态、插入等待队列
- 进程的唤醒：移出等待队列、设置为就绪态、插入就绪队列

进程的通信：
- 共享存储：有可以直接共享的存储空间、使用同步互斥供给对读写进行控制
- 消息传递：直接通信、间接通信
- 管道通信：其实是连接了一个读进程和一个写进程的文件，也是一个大小固定的缓冲区。管道是单向传输的。

### 关于线程

线程是程序执行流的最小单位。引入线程的目的是：减小程序在并发执行时所付出的时空开销
线程与进程的比较：
- 调度：在传统的操作系统中，拥有资源和调度的基本单位是进程，但是，在引入线程的操作系统中，线程是基本的调度单位，线程切换的代价远远小于进程
- 并发性：进程、线程之间均可以并发执行
- 拥有资源：线程不拥有系统资源，但可以访问进程所拥有的系统资源
- 独立性：某进程中的线程对其他进程不可见，但是同一进程中的不同线程是为了提高并发性而创建的，因此它们共享进程的地址空间和资源
- 系统开销：调度线程的开销远远小于调度进程的开销
- 线程支持多处理机系统


线程也有就绪、阻塞、执行三态。也有 TCB。

线程的实现方式：
- 用户级线程：所有关于线程管理额工作都有应用程序在用户空间中完成，内核意识不到线程的存在。调度仍然以进程为单位。优点：（1）无需切换到内核态；（2）线程调度算法由每个进程自己设计；（3）用户级线程的实现与操作系统无关；缺点：（1）当线程执行一个系统调用时，不仅该线程被阻塞，而且进程内的所有线程都被阻塞；（2）无法发挥多处理机优势，每次系统只给进程分配一个 CPU，因此只有一个线程被执行
- 内核级线程：线程管理的所有工作在内核中进行。这样可以发挥多处理机优势，如果进程中的一个线程被阻塞，内核可以调度运行该处理机中的其他线程；线程切换开销小（但是效率不如用户级线程）。但是，同一进程中的线程切换时，需要从用户态转到核心态，开销较大。
- 组合方式：一个内核级线程对应多个用户级线程。

多线程模型：用于描述用户级线程和内核级线程之间的关系。一对多、一对一、多对多


## 处理机调度
三级调度：高级（作业调度）、中级（内存调度）、低级（进程调度）
调度的目标：
- CPU 利用率：CPU 忙的时间占总时间的比例
- 系统吞吐量：单位时间内 CPU 完成作业的数量
- 周转时间：作业完成时间-提交时间；由此衍生出平均周转时间、带权周转时间、平均带权周转时间
- 等待时间、响应时间


- 先来先服务（不可剥夺）
- 短作业优先：对长作业不利，且未考虑作业的紧迫程度
- 优先级调度（可以有抢占式、非抢占式，优先级可以是动态的、静态的）；对于优先级来说：系统进程>用户进程；交互型进程>非交互性进程；IO 进程>计算进程
- 高响应比优先：响应比= （等待时间+要求服务时间）/要求服务时间，同时有 FCFS 和 SJF 的特点
- 时间片轮转 (Round Robin)
- 多级队列

## 进程访问临界资源（难）
为了保证对于临界资源的正确使用，我们会把对临界区的访问过程分为四个阶段：进入区（设置访问临界区的标志）、临界区、退出区、剩余区。进程之间的关系可以是同步（直接制约关系）或者互斥（间接制约关系），为了使得两个进程不能同时访问临界区，进程间的同步机制必须满足以下条件：
- 空闲让进：临界区空闲时，允许一个正在等待的进程进入临界区
- 忙则等待：当已有进程进入临界区时，其余还想进入临界区的进程必须等待
- 有限等待：请求访问的进程必须在有限时间内进入临界区
- 让权等待：当进程无法进入临界区时，必须释放处理器，防止忙等待

为了解决这些同步与互斥问题，我们通常会引入一种较强的机制——信号量机制，它只能被两个标准原语：P 操作和 V 操作访问。一般来说，P 操作会使得信号量的值减少；一旦小于 0，就会将申请访问的进程挂载到等待队列上；V 操作则会使得信号量的值增加，如果小于 0，还会唤醒正在等待的进程。

除此之外，我们来介绍“管程”。我们使用一个数据结构来代表某种共享资源，将这种数据结构核对结构实施一系列过程所构成的资源管理程序称为“管程”。简单来说，管程就是把信号量和所有能做的操作“打包”起来了。

### 使用信号量实现的经典问题（重难点）
接下来，我们介绍信号量使用的几个经典模板

- 用于控制同步
![[9eff49d0f31e6132244400fe5f1bc39.jpg]]
P 1 之后 V 一下，P 2 之前 P 一下。利用相同的手法可以实现前驱关系。

- 用于控制互斥
![[62ed3aaca56ea880f667d6ccfda7160 1.jpg]]
简单。记得用前 P，用后 V。

- 生产者-消费者问题
![[7ba2f823cca780dba732fd4773d4003.jpg]]
![[402014e51fdc819c88737c97124c3bb.jpg]]
需要三个信号量。其中一个用于控制互斥地访问缓冲区；另外两个记录缓冲区已有的物品数量和剩余的空位数量

吃水果问题：
![[1e9bcba0aa3f4096a523e773e6885be.jpg]]
这里面只用了三个信号量。这是因为盘子中最多只能装一个水果，所以用于记录空位的信号量和用于互斥访问盘子的信号量可以是一个。因此这里减少了 2 个信号量。

- 读者/写者问题
]有同质的个体->可以使用计数变量。但是注意计数变量的访问也得是互斥的。再增加一个 $w$ 信号量和一对 PV 操作就可以读写公平。

- 哲学家进餐问题
![[b5cbba96e605467a1ebeb22dc9ccafd.jpg]]
哲学家进餐问题是说每个进程需要两个以上的临界资源，这个时候的一种解法就是制定一些新的规则。例如，这个解法中我们要求每次场上只能有一个人正在拿筷子，这就会防止多个哲学家同时取筷子的情况（这个情况导致死锁）

- 吸烟者问题
![[f5ac81010fe05a69db9813dd83eccd4.jpg]]
这里其实更多的是一个同步问题：吸烟者吸完烟后会给 finish，从而使得供应商继续供应材料；供应商供应完材料后会给 offer，从而提醒吸烟者吸烟。


## 死锁的产生、检查与解除
死锁：各进程互相等待对方手里的资源，从而导致各个进程互相阻塞，无法向前推进的现象。死锁产生的原因包括：
- 系统资源的竞争
- 各个进程的推进顺序非法
死锁产生的必要条件包括：
- 互斥条件
- 不剥夺条件：资源在未使用完之前，不能被其他进程强行夺走
- 请求并保持条件：进程至少已经保持了一个资源，但是又提出了新的请求
- 循环等待条件
那么，我们解除死锁的策略包括：
- 破坏不剥夺条件：常用于状态易于保存和易于恢复的资源，对于打印机等则无效
- 破坏请求与保持条件：一次分配完成（但是，造成严重的资源浪费和饥饿现象）
- 破坏循环等待条件：给出申请资源的顺序，例如，只能按照递增的顺序申请资源

**这里的重点是银行家算法，即找到一个合理的资源分配序列的方法** 

对于死锁的检测，我们通常使用资源分配图法。我们使用圆圈代表一个进程，使用框代表一类资源。从进程到资源的边称为“请求边”。化简的方法就是消边：找到不阻塞也不孤立的进程，将与之相连的边全消去，直到不能消除为止。此时看所有进程是否已被满足。


