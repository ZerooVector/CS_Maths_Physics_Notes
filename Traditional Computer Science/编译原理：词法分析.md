#TraditionalComputerScience  #CompilePrinciple

## 使用集合表达字符串
我们首先定义字母表。任何一个非空、有限集合 $\Sigma$ 都可以是字母表。我们记字符串集合为 $\Sigma^{\star}$，首先 $\epsilon \in \Sigma^{\star}$（这里 $\epsilon$ 表示空串），其次，如果 $a \in \Sigma,\alpha \in \Sigma^{\star}$，那么 $a \alpha \in \Sigma^{\star}$。我们可以定义字符串的长度。

设 $\alpha\in \Sigma^{\star}$，我们可以直观地定义其前缀和后缀（注意，字符串是其本身的前缀和后缀），类似于真子集，我们可以定义真前缀、真后缀。如果从一个字符串中删去前缀和后缀，剩下的部分叫做子串。显然，字符串是其本身的子串。

我们可以定义两个字符串 $\alpha,\beta$ 的连接 $\alpha \beta$，显然 $\Sigma^{\star}$ 对连接这个运算封闭，且连接运算一般不满足交换律。我们也可以定义 $\alpha$ 的 $n$ 次幂 $\beta = \alpha \alpha\cdots \alpha$（$n$ 个 $\alpha$），特别地，$\alpha^{0} = \epsilon,\forall \alpha$。

现在我们考虑字符串的集合。设 $A,B$ 是两个字符串的集合。我们容易仿照直积（卡氏积）的定义给出字符串集合的乘积：
$$
AB = \{\alpha\beta |(\alpha \in A)\land(\beta \in B) \}
$$
显然，如果 $B = \{\epsilon\}$，那么 $AB = A$。特别地，若 $B = \phi$ ，那么 $AB = \phi$。
我们也可以定义集合的 $n$ 次幂：$A^{n}=AA\cdots A$（$n$ 个 $A$）, 特别地，$A^{0} = \{\epsilon\},\forall A$。
我们定义符号串集合的闭包。$A$ 的正闭包定义为：
$$
A^{+} = A^{1} \cup \cdots A^{\infty}
$$
$A$ 的自反闭包定义为：
$$
A^{\star} = A^{0} \cup A^{1}\cdots A^{\infty}
$$
容易注意到：
$$
A^{+}= AA^{\star} \quad  A^{\star} = A \cup  A^{0}
$$

## 正规式（正则表达式）与正规集
正规式（正则表达式）只是一种对于语言规则的描述，只是一个类似于 "$1+2$"这样的表达式。
一个正规式匹配一种特定的语言（这里我们暂且将“语言”这个词定义成字符串的集合）。首先，$\epsilon$ 和 $\phi$ 是 $\Sigma$ 上的正规式，它们分别匹配了语言 $\{\epsilon\}$ 和 $\phi$。对于任何 $a \in \Sigma$，$a$ 都是 $\Sigma$ 上的正规式，它匹配语言 $\{a\}$。若 $r,s$ 都是 $\Sigma$ 上的正规式，它们匹配了语言 $R,S$，那么 $r|s, r\cdot s,(r)*$ 这三个表达式都是正规式（不要把这三个东西考虑成三个运算，直接考虑成三种写法），它们分别匹配了语言 $R \cup S, RS, R^{\star}$。我们将正规式匹配的语言（字符串的集合）称为正规集。

## 确定性有限状态自动机（DFA）
DFA 也可以建模语言。
一个确定性有限状态自动机形式化地定义为一个五元组 $M = \{S,\Sigma,f,S_{0},Z\}$。其中 $S$ 为状态的集合，$\Sigma$ 是字母表，$S_0$ 是 $M$ 的唯一初态，$Z$ 是 $M$ 的终态集合，$f: S \times \Sigma \rightarrow S$ 是状态转换函数。
DFA 可以匹配特定的串。对于字符串 $\alpha$，如果存在一条从初态到某一终态的路径，且该路径上历经的状态转移函数 $f(\cdot,a_{i})$ 的 $a_{i}$ 的连接恰好是 $\alpha$，我们就称 $\alpha$ 被 $M$ 所识别。一个 $M$ 能够识别的字符串的集合记为 $L(M)$，这也就是被 $M$ 所接受的“语言”，等价于上面被正规式所接受的正规集。
两个 DFA 等价，当且仅当它们接受的“语言”等价。

## 不确定有限状态自动机（NFA）
一个 NFA 同样形式化地定义为一个五元组 $M = \{S,\Sigma,f,S_{0},Z\}$。唯一不同的是，NFA 的状态转换函数：$f: S \times \Sigma \rightarrow \{0 \ or \ 1\}$ ，其中 $|\{0 \ or \ 1\}| = |S|$，也就是每个状态 $s_{j}, \forall j$ 由 1 Bit 表示它是不是状态 $s_{i}$ 下接收到特定字符后可转移到的后继状态。
NFA 也可以匹配特定的串。与 DFA 不同的是，这里的 $f(\cdot,a_{i})$ 的 $a_{i}$ 不是唯一的，只要我们能在初态到终态的路径上找到 $a_{i}^{(k)} \in \{a_{i}\}$ ，使得 $a_{i}^{(k)}$ 的连接恰好是 $\alpha$，我们就称 $\alpha$ 被 $M$ 所识别。
如果有 NFA：$M$ 和 DFA：$M'$，我们称它们等价，当且仅当 $L (M) = L(M')$。我们给出一个不易察觉的单向的等价关系：对于任意 NFA：$M$，都存在一个 DFA：$M'$ 与之等价。我们的证明是通过构造完成的（直接给出 NFA 转化成 DFA的方法）。
在给出具体的转化之前，我们先定义两个概念。
我们定义$\epsilon$ 闭包：若 $I \subset S$，则 $\epsilon-closure(I)$ 定义为：
- $\forall s_{i} \in I, s_{i} \in  \epsilon-cl(I)$
- $\forall s_{i}\in I$，$\forall s_{j}$，若 $s_{j}$ 可以从 $s_{i}$ 开始，仅仅经由转移条件为 $\epsilon$ 的转移过程到达，则 $s_{j} \in \epsilon-cl(I)$。
我们定义 $I_{a}$：若 $I \subset S, a \in \Sigma$，$J$ 是从 $s_{i} \in \epsilon-cl(I)$ 出发经由转移条件为 $a$ 的转移过程到达的状态 $s_{j}$ 的集合 $\{s_{j}\}$，则 $I_{a} = \epsilon-cl(J)$。
我们接下来具体给出转化的方法：子集法（难以使用形式逻辑阐述这个方法，暂时略）

## DFA 的化简
我们现在希望寻找一个状态数最少的 DFA $M'$，使得 $L (M) = L(M')$。此时，$M'$ 既没有无关状态，也没有彼此等价的状态。如果我们有一个 DFA $M$，$\forall \omega, f (q_{1},\omega) = p_{1}, f (q_{2},\omega) = p_{2}$，如果 $p_{1}, p_{2} \in L(M)$ 或者 $p_{1}, p_{2} \not \in L(M)$，则称 $q_{1},q_{2}$ 是等价的。
我们使用划分法。首先建立集合，区分终态和非终态 $\pi = \{Z,K-Z\}$。经过一些操作，假定集合中有 $m$ 个子集：$\pi = \{I_{1},I_{2},\cdots ,I_{m}\}$（属于同一子集的状态是待区分的，而处于不同子集的状态是可区分的），现在，考察各个子集 $I_{i}$ 中的状态是否等价，将不等价的状态划分到不同的子集，形成 $\pi_{new}$。最后，我们只需在每个子集中选择一个状态作为代表即可。

从 $M$ 的初态开始，输入任何序列都无法到达的状态称为无关状态。寻找无关状态是简单的，只需从初态开始对 DFA 做广度优先遍历即可。

## NFA 与正规式的等价性
现在，我们说明：$\Sigma$ 上每一个 NFA $M$ 所接受的语言 $L(M)$ 是 $\Sigma$ 上的一个正规集，反之亦然。我们直接通过构造的方式给出证明。


