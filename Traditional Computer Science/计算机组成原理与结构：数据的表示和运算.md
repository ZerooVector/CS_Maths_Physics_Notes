#TraditionalComputerScience 

关于数据的表示，最重要的是数据的表示范围。注意：补码可以表示的范围比原码和反码都多一个“1”（在负数的位置上！）


#### 各种奇妙的错误 1
![[b103242dbb91f13960dd86f7113bfb1.jpg]]
死因：没发现 BCD 是四位转 1 位

![[dcda27daa5580bd19deb518c43c0cd0.jpg]]
死因：傻了

![[885bb4c95353555311276e36903c700.jpg]]
死因：$x$ 应该为 0 或者正数

![[5fc399cac065a6a8b50f2cac2fe14b6.jpg]]
死因：显然的，B 是-128，而+128 的移码超出了表示范围（当时不熟悉移码）

![[67d7e1b56b9e6aa4382feb811441741.jpg]]
死因：确实简单

对于补码加减法，我们首先有三个方式来判断溢出：
- 参加运算的两个数符号相同，却与结果符号不同（两个正数相加得负，或两个负数相加得正）
- 符号位的进位与最高数位的进位不同
- 双符号位

对于逻辑移位，直接移位即可。但是算术移位较难：
- 原码无论正负，全都补充 0
- 反码正补 0，负补 1
- 补码正补 0 ，负：左 1 右 0

加法器相关：
- $A_{i}B_{i}$ 是进位产生函数， $A_{i}\oplus B_{i}$ 是进位传递函数
- 对于串行进位加法器，每一级的进位都依赖于前一级的进位。若每次进位时间为 1 单位，则 $n$ 位的串行进位加法器需要 $n$ 单位。这也叫“行波进位”
- 对于并行的情况，我们可以将全加器的式子展开，得到一种超前进位加法器。一组超前进位加法器完成运算的时间仅仅为 1 个单位。
- 实际中，我们有两种加速方式：（1）组间串行，组内并行；（2）组间并行，组内并行：第一时间单位产生最低组的实际进位、其他组的 $G,P$；第二时间单位将每个组输入的上一组的 $C$ 输进去，第三时间单位产生所有其他的进位
- 加法器有四个标志：溢出 $OF$、符号 $SF$、零 $ZF$ 和进位、借位 $CF$。注意：进位输入 $C_{in}$ 为 0时，$CF$ 为实际进位；否则，$CF$ 为进位取反

**重中之重：补码加减乘除运算**

- 逻辑运算

- 浮点数的规格化、表示范围
- 运算前记得先对阶，小阶向大阶看齐！

- IEEE 754


#### 各种奇妙的错误 2

![[3a756cb78ba95f8f9b1aff310b75eb5.jpg]]
死因：（1）不是根据运算结果来确定符号，而是根据乘数和被乘数的符号的异或来确定结果符号
（2）记得考虑符号位，那也算一位

![[9fa568578e8552dde08115cc251f37f.jpg]]
死因：回忆数电，ALU 中经常使用的求负数的补码方法就是输入反码再+1

![[9aa6e840fe94d1fd5fd1456e1b83030.jpg]]
死因：牢记“铁律”：使用双符号位判断溢出，看看两个进位的异或标记再判断进位（减法的时候效果就是判断借位啦）

![[f32d3aa8eb2156ee1c7a974bd2478fb.jpg]]
死因：当且仅当右移时才会导致舍入。而且记住，规格化和和对阶是两个不同的事情

![[b76c0abc3d1efa81b575d47e8eaa5ea.jpg]]
死因：睁眼看看，均含有 2 位符号

![[ae186c8d0f043ca90299c73a2a60569.jpg]]
死因：记得 IEEE 是有一位“隐藏位”的，千万别忘了

![[a4b25b5298e93ea110bbfa47571b094.jpg]]
死因：分类讨论吧。再错就真的没救了

