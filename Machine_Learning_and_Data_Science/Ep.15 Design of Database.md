#MLorDS 

我们要设计更好的数据库的初衷是：不希望将所有属性存在一个数据库内，这使得增加、删除数据都显得困难，数据也有很冗余，这是因为数据之间存在着某种依赖关系

## 数据之间的函数依赖
对任意元组 $t_{1},t_{2}$，若它们在 $X$ 上的属性值相等，$Y$ 上的属性值也相等，那么称 $X$ 函数决定 $Y$，或 $Y$ 函数依赖于 $X$。记为 $[FD]X \rightarrow Y$ ，例如
- 一个借书证号对应一个读者
- 一个借书证号可以唯一确定读者所在的单位

函数依赖必须对所有数据均成立才行，这是一种语义范畴的概念，必须通过对现实世界的建模来建立这种依赖

- 如果 $Y$ 不是 $X$ 的真子集，则称 $Y$ 是 $X$ 的非平凡函数依赖，反之则称为平凡的函数依赖。根据定义，平凡的函数依赖是显然成立的。因此，我们只讨论非平凡的函数依赖。

- 如果 $X$ 的全体才能映射到 $Y$，那么这是完全函数依赖；如果 $X$ 的一部分就能映射到 $Y$，那么这个就是部分函数依赖

- 如果 $X \rightarrow Y$，而且 $Y \not \rightarrow X$，而且 $Y \rightarrow Z$，那么必然有 $X \rightarrow Z$，称 $X \rightarrow Z$ 为传递函数依赖

现在的问题是给定了一些函数依赖，问其他的一些函数依赖是否成立的问题。这就是函数依赖的逻辑蕴含要研究的问题。若一个关系模式 $R$ 上带有函数依赖集 $F$，但是，$R$ 上的一些函数依赖 $X \rightarrow Y$ 没有被显式地给出，那么就称 $F$ **逻辑蕴含** $X \rightarrow Y$ 

## 函数依赖公理
设存在关系模式 $R(U,F)$，而且 $X, Y, Z ,W \subset U$，Armstrong 公里给出三条准则：
- 若 $Y\subseteq X \subseteq U$，那么 $F|= X \rightarrow Y$（整体决定部分）
- 若 $F|= X \rightarrow Y$，$Z \subseteq U$，那么 $F|= XZ \rightarrow YZ$（增广律，在一个函数依赖左右分别增加属性，公理依然成立）
- 增广律的扩展形式：$XZ \rightarrow YW$，只要 $W \subseteq Z \subseteq  U$，极端地, $F|= XZ \rightarrow YW$
- 若 $F|= X \rightarrow  Y, F |= Y \rightarrow Z$，那么 $F|= X \rightarrow Z$

我们还有三条推论：
- $X \rightarrow Y ,X \rightarrow Z$，那么 $X \rightarrow YZ$（联合规则）
- $X \rightarrow Y ,Z \subseteq Y$，那么 $X \rightarrow Z$（分解规则，就是联合规则的反向推导）
- $X \rightarrow Y, YZ \rightarrow W$，那么 $XZ \rightarrow W$（伪传递规则）

### 属性闭包
有关系模式 $R(U,F)$，$U = \{A_{1},\cdots ,A_{n}\}$，$X \subseteq U$ ，所有用公理推导出的函数依赖的 $X \rightarrow A_{i}$ 中 $A_{i}$ 的集合称为 $X$ 关于函数依赖集 $F$ 的闭包，记为 $X_{F}^{+}$，换言之，$X_{F}^{+}$ 就是由 $A$ 决定的所有东西

##### Theorem 
以下两个命题是等价的：
- 可以利用公理导出 $X \rightarrow Y$
- $Y \subseteq X_{F}^{+}$ 


![[Pasted image 20230406141718.png|500]]

如果 $G^{+}=F^{+}$，那么就说函数依赖集 $F$ 覆盖 $G$，或者说 $F$ 与 $G$ 等价
可以证明，如果要判定 $F \subseteq  G^{+}$，只需对 $F$ 中的函数依赖 $X \rightarrow Y$，考察 $Y$ 是否属于 $X_{G}^{+}$ 即可

### 最小依赖集
若函数依赖集 $F$ 满足以下条件，则说 $F$ 是一个最小函数依赖集：
- $F$ 中所有函数依赖的右侧都是单属性
- 从 $F$ 中去除一个元素后的结果与 $F$ 自身不等价
- $F - \{X \rightarrow A\} \cup  \{Z \rightarrow A\}$ 与 $F$ 不等价。其中，$Z$ 是 $X$ 的真子集

可以使用如下的方法求出最小依赖集：
- 右侧写成单个的形式
- 逐一检查每个函数依赖，看去除以后是否等价。具体的检查方法是：去=取出一个函数依赖，求其左侧属性的关于 $X$ 的闭包，如果闭包中包含其右侧元素，那么这个函数依赖可以去掉

## 模式分解
将大的关系模式 $R(U)$ 分解成很多小的关系模式 $R_{1}(U_{1}),\cdots ,R_{k}(U_{k})$，如果 $\cap_{i} U_{i}=U$，则称这是一个模式分解。分解后的模式应当与原模式等价，这要求：
- 无损连接分解：分解后的模式不损失任何信息（简单地来说，将分解后的关系模式做自然连接，可以恢复到原来的关系模式）
- 分解保持依赖性：分解后的模式保持原来的函数依赖

- 第一范式：如果关系模式 R 的每一个属性对应的域值都是不可再分的，称模式 R 属于第一范式（不能“表中有表”）
- 第二范式：在第一范式的基础上，所有非主属性都完全依赖于 R 的每个候选键
例如：这两个关系属于第二范式，它是从一个满足第一范式的关系分解得到的
![[Pasted image 20230410132729.png|400]]
- 第三范式：在第一范式基础上，没有非主属性传递依赖于 R 的候选键（因为这些传递依赖总可以再开一张表，单独储存）
- BC 范式：若 R $\in$ 1NF，而且 R 中没有任何属性传递依赖于 R 中的任一候选键，则关系模式 R 属于 Boyce-Codd 范式（BCNF）（实际使用的判断标准更可能是：F 是 R 上的函数依赖集, 对于 F 中的每一个函数依赖 X→Y，X 必含有候选键）
在函数依赖的范围内，BCNF 已达到了关系模式的最大分离，已经消除了插入、删除异常，是**函数依赖范围内**能够达到的最高范式

![[Pasted image 20230410135024.png|400]]
这个算法可以达到无损连接和保持函数依赖。

![[Pasted image 20230410135555.png|400]]





