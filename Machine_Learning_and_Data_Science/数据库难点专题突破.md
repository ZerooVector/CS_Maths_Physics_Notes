#MLorDS 

***这个文件的主要目的是，归纳数据库原理中可能出现的难点题、大题、证明题，等等*** 

## 数据库设计理论

### 函数依赖
在数据库的设计过程中，我们常常会遇到存储异常等现象。这些现象出现的原因是，数据库的某些列之间存在函数关系，导致某些数据被重复地存储了。为了消除这种存储异常现象，我们需要先研究数据库上的函数依赖关系。

##### Def  函数依赖
- 如果 $X \rightarrow Y$，且对于任意的 $X' \subset X$，$X \rightarrow Y$ 都不成立，我们就说 $X \rightarrow Y$ 是一个**完全函数依赖**
- 如果 $\exists X' \subset X$，使得 $X' \rightarrow Y$ 成立，那么我们称 $X \rightarrow Y$ 是一个**部分函数依赖**，也就是说，$Y$ 仅仅依赖于 $X$ 的一部分。 
显然，如果有关系模式 $R(U)$，且 $X \rightarrow U$ 是一个完全函数依赖，那么 $X$ 是 $R$ 的候选键；如果 $X \rightarrow U$ 是一个部分函数依赖，那么 $X$ 是 $R$ 的超键
- 如果 $X \rightarrow Y$，但是 $Y \not \rightarrow X$，而且 $Y \rightarrow Z$，那么必然存在 $X \rightarrow Z$，我们将这样间接地经过 $Y$ 的传递而形成的“复合函数“称为**传递函数依赖**

##### Def  逻辑蕴含
我们将关系模式 $R$ 上任一关系都满足的函数依赖，称为关系 $R$ 满足的函数依赖集。我们现在希望研究如何通过函数依赖集中包括的已知函数依赖推出未知的函数依赖这一问题。我们定义关系模式 $R(U)$ 和定义于此关系模式上的函数依赖集 $F$，那么如果有一个未出现在函数依赖集中的函数关系 $X \rightarrow Y$，我们就称 $F$ **逻辑蕴含** $X \rightarrow Y$ 。

##### Def 函数依赖集的闭包
给定函数依赖集 $F$，所有从 $F$ 中可以推出的函数依赖，也就是所有 $F$ 的逻辑蕴含，称为 $F$ 的**闭包**，记作 $F^{+}$。

### 逻辑蕴含的推理规则

##### Theory 阿姆斯特朗公理
Armstrong 公理是用于推导逻辑蕴含是否存在的一组公理，主要包括三条：
给定关系模式 $R(U)$，其函数依赖集为 $F$，$X,Y,Z,W$ 都是 $U$ 的子集，那么：
- 自反律：若 $Y \subseteq  X  \subseteq  U$，那么 $F |=   X \rightarrow Y$，这可以归结为总体决定部分。
- 增广律：若 $F |= X \rightarrow Y$，那么 $F|= XZ \rightarrow YZ$ ，也就是说，一条函数依赖在左右添加相同的属性，仍然成立
- 传递律：若 $F |= X \rightarrow Y$，且 $F |= Y \rightarrow Z$，那么 $F |= X \rightarrow Z$，也就是说，函数依赖是可以传递的。

从 Armstrong 公理，我们可以导出三条推论，这三条推论分别是：
##### Theory 阿姆斯特朗公理的三条推论
- 合成规则：若 $X \rightarrow Y$，$X \rightarrow Z$，那么 $X \rightarrow YZ$ 成立，也就是说，如果 $X$ 同时决定两个属性，那么 $X$ 当然也就决定两个属性的组合，这条规则可以反着用
- 分解规则：若 $X \rightarrow Y$，且 $Z \subseteq Y$，那么 $X \rightarrow  Z$ 成立。也就是说，$X$ 既然决定了属性 $Y$，那么 $X$ 也决定 $Y$ 的一个子集
- 伪传递规则：若 $X \rightarrow Y$，$YZ \rightarrow W$，那么 $XZ \rightarrow W$

##### Proof
我们接下来逐一给出证明：
- 合成规则：若 $X \rightarrow Y$，则我们在两端添项：$XX \rightarrow XY$。同理，由于 $X \rightarrow Z$，我们也在两端添项：$XY \rightarrow YZ$ 。使用传递律：$XX \rightarrow YZ$，也就是 $X \rightarrow YZ$
- 分解规则：因为 $Z \subseteq  Y$，那么由自反律，$Y \rightarrow Z$。又由于 $X \rightarrow Y$，使用传递律，$X \rightarrow Z$
- 伪传递规则：由于 $X \rightarrow Y$，在两边添项得到 $XZ \rightarrow YZ$，使用传递律，得到 $XZ \rightarrow W$

显然，我们要想知道一条新的函数依赖能不能从现有的函数依赖集 $F$ 中得到，只需要求出 $F$ 的闭包，并检查这条函数依赖是否在 $F$ 的闭包中。这个做法的正确性由 Armstrong 公理的有效性和完备性保证。

### 求属性闭包和最小覆盖

##### Def 属性闭包
设关系模式 $R(U,F)$，$X \in U$，那么所有用公理推出的函数依赖 $X \rightarrow A_{i}$ 中 $A_{i}$ 的属性集合称为属性集 $X$ 关于函数依赖集 $F$ 的闭包，记为 $X_{F}^{+}$。那么，我们现在要计算函数依赖集 $F$ 导出的逻辑蕴含中，左手边为 $X$ 的有哪些，可以简单地通过求 $X$ 的属性闭包实现。

##### Algorithm 计算属性集 $X$ 的闭包的算法
要求 $X$ 的属性闭包，需要使用以下步骤：
- 在函数依赖集 $F$ 中寻找左侧是 **$X$ 的子集**的函数依赖，如果这个函数依赖的右手边不包含在 $X$ 中，就可以将其添加到 $X$ 中
- 不断重复这一过程，直到 $X$ 不再增长，或 $X$ 中包含了关系模式中所有的属性 $U$ 为止，算法结束

##### Def 函数依赖集的等价
如果两个函数依赖集  $F,G$ 所能导出的逻辑蕴含是相同的，也就是说，两个函数依赖集的闭包相同，那么我们就说，两个函数依赖集是等价的，或者说 $F$ 覆盖 $G$，或者说 $G$ 覆盖 $F$。

既然有了函数依赖集等价的定义，那么我们自然想要将一个函数依赖集化简到最简，于是我们引入了最小函数依赖集（最小覆盖）的概念

##### Def 函数依赖集的最小覆盖
如果一个函数依赖据满足以下条件，那么我们称其为最小覆盖：
- $F$ 中所有函数依赖的右手边都是单属性
- 对 $F$ 中任意函数依赖 $X \rightarrow A$，$F-\{X \rightarrow A\}$ 与 $F$ 不等价，也就是说，$F$ 中不能再去除任意一条函数依赖
- 对 $F$ 中任意函数依赖，$F -\{X-A\}+\{Z-A\}$ 与 $F$ 也不等价，其中 $Z$ 是 $X$ 的真子集。也就是说，$F$ 中不能再去除一个函数依赖的子集。这里的 $F$ 可以看作是一堆“基向量”，不能再从中删去任何东西。

##### Algorithm 求解最小覆盖
要求 $F$ 的 最小覆盖，需要不断进行以下两个步骤：
- 反向利用合成规则，将 $F$ 中函数依赖的右手边转化成单属性
- 将 $F$ 中每一个函数依赖 $X \rightarrow A$ 去掉后求关于 $X$ 的闭包。如果 $X^{+}$ 中包含 $A$，那么这个函数依赖不能去掉
- 检查所有的函数依赖
- 

### 模式分解
我们把将一个大的关系模式分解为多个小的关系模式的过程称为模式分解。分解后的模式最好应该满足以下两个特性：
- 无损连接：分解后的模式经过自然连接，应该得到原模式，保证了分解不丢失信息
- 分解保持依赖：分解后，函数依赖应该保持（或者应该至少可以导出），保证了分解可以减轻或解决各种异常情况
注意：这两个标准是独立的标准

### 分解模式的规范化
我们一共需要掌握四种范式：
- 第一范式：关系模式 $R$ 中每一个属性对应的值域都是不可再分的
- 第二范式：所有非主属性完全依赖于 $R$ 的每个候选键（候选键中的属性称为主属性，其余称为非主属性）。要想判断一个数据库是否是第二范式，需要将其候选键求出来
- 第三范式：没有非主属性传递地依赖于 $R$ 的候选键

可以证明，如果一个关系模式是 3 NF 的，那么它一定是 2 NF 的。证明如下：
##### PF 
设 $R$ 上的函数依赖集为 $F$，而 $R$ 的键为 $K$，设 $R \in 3NF$ 但是 $R \not \in 2NF$，那么 $R$ 中有非主属性 $A$ 依赖于候选键 $K$。也就是说，存在 $K' \subseteq K$，使得 $F |= K' \rightarrow A$。
又显然由自反律得到: $K \rightarrow K'$，但是 $K' \not \rightarrow K$
于是 $K \rightarrow K'$，且 $K' \rightarrow A$，这与第三范式的定义矛盾。

- BC 范式：没有任何一个属性传递地依赖于 $R$ 的候选键。如果一个关系是 BCNF 的，那么它一定是 3NF 的，这是不证自明的。BC 范式是**函数依赖的范围内，所能达到的最高范式**；最快地检查一个关系模式是否属于 BC 范式的方法：检查关系 $R$ 中的每一个属性是否依赖于其键。

##### Algorithm 将一个关系模式分解为第三范式
给定关系模式 $R(U,F)$，需要做如下步骤：
- 寻找未出现在 $F$ 中的 $R$ 的属性，将这些属性从 $R$ 中去掉
- 计算 $F$ 的最小覆盖
- 按照各个函数依赖关系的左部将其合并
- 如果现在的关系模式不含候选键，则向其中加入一个候选键

##### Algorithm 将一个关系模式分解为 BC 范式
给定关系模式 $R(U,F)$，需要做如下步骤：
- 如果存在 $X \rightarrow Y$，而且 $X$ 不是 $R$ 的键，那么就将 $R$ 分解为 $R_{1}= XY$，$R_{2}= R-Y$
- 不断分解，直到结束


