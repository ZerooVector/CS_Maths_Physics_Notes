#MLorDS 
# 第一章：数据库导论


# 第二章：数据模型
## ER 模型基本知识
### 基本概念
- 实体（Entity）
– 客观存在并可相互区别的事物称为实体。 – 可以是具体的对象，如一个学生, 一本书, 一辆汽车；也可以是抽象的概念或联系，如一堂课, 一次比赛等
- 属性 (Attribute)
实体所具有的某一特征称为属性。 – 一个实体可以由若干个属性来刻画，如学生实体有学号、姓名、年龄、性别、系等方面的属性 – 属性有“类型”和“值”之分，类型是属性名，值就是具体的值
- 联系 (Relationship)
– 在现实世界中，事物内部以及事物之间是有联系的 – 在信息世界中将被抽象为实体内部的联系和实体之间的联系。 ➢实体内部的联系通常是指组成实体的各属性之间的联系； ➢实体之间的联系通常是指不同实体集之间的联系
实体间的联系可能是一对一的、一对多的、多对多的，多个实体之间也可能存在多对多对多的联系，称为多元联系
![[Pasted image 20230322092437.png|400]]
同一实体集内部可能有联系，例如职工内部有领导和被领导的关系

### 画 ER 图


### 层次模型
- 定义：用树型结构表示各类实体以及实体间的联系。
- 要求：– 有且只有一个结点没有双亲结点，这个结点称为根节点 – 根以外的其它结点有且只有一个双亲结点
- 优点：（1）数据结构比较简单，清晰。 – （2）层次数据库的查询效率高。 – （3）它提供了良好的数据完整性支持
- 缺点：（1）不能直接表示两个以上的实体型间的复杂的联系和实体型间的多对多联系，只能通过引入冗余数据或创建虚拟结点的方法来解决，易产生不一致性 – （2）对数据的插入和删除的操作限制太多。 – （3）查询子女结点必须通过双亲结点。 – （4）由于结构严密，层次命令趋于程序化

### 网状模型
- 最大的好处：可以清晰地表示非层次关系
- 要求：– 允许一个以上的结点无双亲 – 一个结点可以有多于一个的双亲
- 优点：– 能够更为直接地描述现实世界，如一个结点可以由多个双亲； – 用指针实现数据间的联系，具有良好的性能，存取效率较高；
- 缺点：– 结构比较复杂，而且随着应用环境的扩大，数据库的结构就变的越来越复杂，不利于最终用户掌握； – 其 DDL、DML 语言复杂，用户不容易使用；访问数据时必须自行选择存取路径，增加了程序编写的负担。

### 关系模型
在关系模型中，基本数据结构被限制为二维表，一张二维表称为一个关系
- 关系：就是一张二维表，一个关系可以用于描述一个实体集
- 属性：一个关系有多个列，每一列为关系的一个属性 ➢如学生关系中，有属性名学号、姓名、出生年月
- 域：一个属性对应一个值的集合。域是属性的取值范围 ➢如学号的域是7位字符数字的集合，学生姓名是汉字字符串的集合
- 元组和其分量：关系是元组的集合，一个元组对应实体集中的一个个体。 – 一个元组由若干个分量组成。一个分量对应一个属性值
- 键：– 键是一个或多个属性组成的，能够唯一标识一个元组。 – 一个关系中可能有多组属性都能够起到标识元组的作用。因而，一个关系中可能有多个键 – 选择其中的一个作为主键，其余为候选键
- 关系模式：对关系结构的描述称为关系模式 (relation schema)➢如学生关系可表示为： 学生（学号, 姓名, 出生年月, 性别, 入学年份, 班级） – 关系数据库模式是一组关系模式的集合，这组关系模式对应的关系的集合称为关系数据库

关系模型中，最基本的数据结构就是“关系”，一张表格不仅可以表示一个实体集，还可以表示实体集之间的联系（例如选课表）。关系必须是规范化的，第一范式的条件是关系的每一个分量必须是不可分的数据项。

关系数据库的完整性约束包括实体完整性、参照完整性、用户自定义完整性

- 优点：(1) 数据结构简单 ◼ (2) 一体化的数据子语言 ◼ (3) 数据独立性高 ◼ (4) 面向集合的存取方式 ◼ (5) 坚实的理论基础 ◼ (6) 有利于开展其他应用

### 面向对象模型
- 对象是由一组数据结构和在这组数据结构上的操作的程序代码封装起来的基本单位。对象由属性和方法组成
- 对象标识：概念：面向对象数据库中的每个对象都有一个唯一的不变的标识称为对象标识 (OID)
- 封装：每一个对象是其状态与行为的封装 ◼ 封装是对象的外部界面与内部实现之间实行清晰隔离的一种抽象，外部与对象的通信只能通过消息 ◼ 对象封装之后查询属性值必须通过调用方法
- 类：对象类 (简称类)：共享同样属性和方法集的所有对象构成了一个对象类 ◼ 实例：一个对象是某一类的一个实例 (instance)

缺点：缺乏通用数据模型； ◼ 缺乏理论基础； ◼ 缺乏友好的用户界面与工具环境； ◼ 缺乏有力的查询优化。 ◼ 商业上没有建立坚实的基础



# 第三章：关系代数

# 第四章：SQL 的使用


# 第五章：查询优化
