#MLorDS 

## DBMS 的查询处理过程和基本算法
- 查询分析：判断语句是否符合 SQL 规则
- 查询检查：检查语句中的数据库对象是否存在；视图消解；检查权限；检查完整性约束。在 DBMS 内部，使用关系代数表达式 （查询树）来记录语句
- 查询优化：选择高效执行的查询处理策略
- 查询执行

查询处理过程可以有两种方式：
- 解释方式：类似于 Python
- 编译方式：类似于 C++，已经保存了优化好的代码，适用于重复查询

### 基本操作的实现方法
#### SELECT 
![[Pasted image 20230320133321.png|400]]

- 顺序扫描 ：按照元组的物理顺序扫描每个元组，适用于**选择率很高或者元组总数较少** 的情况，例如 C 1
- 二分查找：适用于已经排序后的情况，例如 C 2 中如果 Sno 已经排过序了，那么二分查找
- 索引扫描：是通过索引先找到指针，再通过指针指到数据。**选择率较低时**，索引扫描优于顺序扫描，但是选择率较高时，读入内存的数据块很多，索引自身还需要维护，那么效率就会低于顺序扫描
![[Pasted image 20230320134211.png|400]]
- 合取索引扫描：
	- 组合索引：直接使用组合索引
	- 单独索引：**仅仅在一个条件的属性上有索引** 先用索引找到符合这一条件的元组，再在这些元组上检查其他条件是否得到满足
	- 多个索引：**在多个条件对应的属性值上分别带索引** 先检索满足单个条件的指针集，再取这些指针集的交集，就是满足合取条件的指针
- 析取索引扫描：
	- 多个索引：分别检索取并集
	- **只要任何一个条件没有索引，就必须采用其他方法** 

#### JOIN 
![[Pasted image 20230320134904.png|400]]

- 嵌套循环：对每一个学生，检查其是否选了某节课，直至两层循环结束为止
- 索引嵌套循环：在其中一个属性上使用索引查找
![[Pasted image 20230320135411.png|400]]

- 排序合并：Student 和 SC 都已经排好序，有两层循环（实际上是双指针）先读取一个 Student 的 Sno，再去 SC 找 Sno 相同的元组。当扫描到第一个不同的值时，返回 Student 向下扫描
![[Pasted image 20230320135720.png|400]]
- 散列连接
	- 划分阶段：求包含元组较少的表求每行的 Hash 值
	- 试探阶段：将另一张表也求 Hash，并尝试连接两张表中 Hash 值相同的元组
	- 最后再判断属性值是否真的相同

#### SELECT (COLUMN)
主要需要考虑如何消去重复元素
- 排序法：进行排序，相同的只留一个
- 散列法：每个元组散列到相应的桶中

#### 集合运算
- 并、差、交：使用排序合并法
- 笛卡尔积：嵌套循环法

## 查询优化的实例
在实际的 DBMS 中，用户不需要考虑如何优化。系统的优化效率显然高于用户。
![[Pasted image 20230320141815.png|400]]

查询优化的代价：磁盘 IO+CPU 处理+内存开销+通信代价

两种优化方法：代数优化、物理优化
![[Pasted image 20230320142552.png|400]]

第一种方式：



![[Pasted image 20230320143501.png|400]]
![[Pasted image 20230320143631.png|400]]
![[Pasted image 20230320143841.png|400]]
![[Pasted image 20230320144210.png|400]]

这是通过减少参与连接的元组个数的方式来优化的。因为笛卡尔积需要全部的元组组合；而连接时不需要生成全部的元组组合。先选择再连接不需要将所有的 Course 加入操作。基于索引扫描的方法可以进一步提高性能。
![[Pasted image 20230320144640.png|400]]

## 代数优化（非常难）
你可以通过过一些运算律化简表达式：
- 笛卡尔积和连接有交换律：选择小的关系作为外关系进行连接
- 笛卡尔积和连接有结合律：
- 投影串接定律：对同一表达式中的多个投影可以转换成在最小属性集上的投影，例如，先在 ABC 上投影再在 BC 上投影等价于在 BC 上直接投影
- 选择串接定律：选择条件可以合并，一次检查全部条件，合并的条件也可以拆开
- 选择和投影的交换律：
	- 如果选择和投影针对了同样的属性集，那么选择和投影可以交换
	- 否则，先做 $F$ 的选择再做 $A_i$ 上的投影相当于先在 $F$ 上投影，再在 $F$ 上选择，再在 $A_i$ 上投影
	- ![[Pasted image 20230320145411.png|400]]

## 代数优化的具体策略
为了提高数据库的效率，我们归纳了一些启发式策略：
- 尽早执行选择操作
- 投影和选择同时进行
- 投影运算与前面和后面的双目运算结合
- 选择和笛卡尔积可以组合成连接运算
- 找出公共的子表达式

一些常见的启发式算法包括：
- 将有多个条件的选择拆开
- 将选择移动到树的叶端
- 将投影移向树的叶端
- 把选择和投影的串接合并成单个选择、单个投影或者一个选择后跟一个投影
- 对运算进行合并
![[Pasted image 20230326234728.png|400]]

![[Pasted image 20230326234806.png|400]]

![[Pasted image 20230326234902.png|400]]

![[Pasted image 20230326235027.png|400]]

![[Pasted image 20230326235147.png|400]]

## 物理优化
- 基于存储路径：启发式规则
- 基于代价估算：估算代价
一般先使用启发式规则选出一些方案，再计算代价，选择代价最小的执行计划

### 基于存储路径
- 选择：如果是小的关系——全表扫描；大关系：如果是主键=值，则选择主键索引；如果是非主属性=值，则估算选择率，选择率低则根据索引，选择率高则全表扫描；如果是非等值查询，同上；如果是合取条件，则先考虑索引，如果没有索引，那就全表扫描；对于析取选择条件，则一般全表扫描
- 连接：如果排序，则使用排序-合并；如果一个表再连接属性上有索引，则索引嵌套循环；如果以上都不适用，且其中一个表比较小，则散列连接；否则使用嵌套循环，使用较小的表作为外表
（适合于解释执行的系统）

### 基于代价估算
