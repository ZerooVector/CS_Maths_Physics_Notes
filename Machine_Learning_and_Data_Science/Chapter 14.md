#MLorDS 
多重事务的执行方式有三种：
- 串行执行
- 交叉并发
- 同时并发

并发处理事务会导致下面的问题：
- 丢失更新：两个事务同时取同一变量，导致某个事务的修改被丢失
- 不可重复读：事务 A 读取值以后，B 做了一些事情（修改数据、删除数据、插入数据），使得事务 A 再次运行时得到的结果与之前不同
- 读脏数据：(读入了其他事务修改过但是未提交的数据)
- ![[Pasted image 20230330142727.png|200]]

## 封锁技术
某一事务 T 在操作某个对象前，会对这个对象加锁；在释放锁之前，其余事务不能对 T 进行控制 
- 共享锁 (Shared Lock)：若事务 T 在对象 A 上加了读锁，那么 T 可以读取 A，但不能写 A，其余数据也可以在 A 上加读锁，但是不能加写锁（其他数据不能写该数据）
- 排他锁（Exclusive Lock）：使得事务 T 可以读取、修改数据 A，其他事务不可再在 A 上加锁，直到写锁被释放

不同的封锁规则带来不同的封锁协议：

### 不同的封锁协议

- 一级封锁协议：事务 T 在修改数据 A 之前，必须在 A 上加排他锁。这可以保证没有丢失更新；但是无法解决不可重复读和读脏数据的情况（这只管了数据写入，没有管读的问题）。
- 二级封锁协议：事务 T 在读入数据 A 之前，要先在 A 上加共享锁，但是读完就释放。这可以防止读脏数据（读不到正在被修改的数据了），但是不能避免不可重复读（共享锁读完就释放，仍然可能有事务来在两次读入中间插入、修改数据）
- 三级封锁协议：将共享锁设置为事务结束再释放，这样就不会有别的东西在事务进行过程中插进来修改数据了！（可以解决所有问题）

### 封锁带来的问题

#### 活锁
![[Pasted image 20230330144733.png|300]]
指某个事务由于请求封锁，但总也得不到锁而长时间处于等待状态
解决方式：先来先服务： ➢当多个事务请求封锁同一数据对象时, 按请求封锁的先后次序对这些事务排队 ➢该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁。

#### 死锁
![[Pasted image 20230330144855.png|200]]
如图，加在 R 1 和 R 2 上的锁永远不可能释放

##### 预防方法：
- 一次封锁法：某个数据将自己用到的所有数据全部加锁。这减小了系统并发度，且需要加锁的对象很难确定。
- 顺序封锁法：所有事务按照指定顺序封锁（维护成本高、难以实现）

##### 实际上，我们允许死锁发生
检测死锁：
- 超时法
- 等待图法：若 V1 等待 V2，则在 V 1, V 2 之间画一条有向边，如果回路出现，则死锁

## 并发调度的正确性
- 显然，所有事务串行执行的策略是正确的，因此，一个并发执行正确，当且仅当并发执行的结果与串行执行相同。因此，只要事务的执行结果与某一个串行调度的结果相同，这个事务就是可串行化的

- 实际上，我们采用另一个定义：如果一个调度是冲突可串行化的，那么它也一定是可串行化的。
- 如果一个调度 S 在保证冲突操作次序不变的情况下，能通过交换两个事务非冲突操作的顺序得到另一个调度 S’，则称调度 S 和 S’冲突等价。如果调度 S’是串行的，称调度 S 为冲突可串行化调度

![[Pasted image 20230403134152.png|400]]

## 保证并发调度的正确性：两段锁协议
“两段”锁的含义: 事务分为两个阶段 
– 第一阶段是获得封锁，也称为扩展阶段。 ➢事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁 
– 第二阶段是释放封锁，也称为收缩阶段。 ➢事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁。

- 遵守两段锁协议的事务可能发生死锁，因此两段锁协议不能完全避免死锁的发生。

## 多粒度封锁
实际上，封锁对象可以是任意的逻辑单元和物理单元，封锁对象的大小就称为封锁的粒度
逻辑单元：属性值、属性值集合、元组、关系、索引项、整个索引、整个数据库等 
物理单元：页（数据页或索引页）、物理记录等

