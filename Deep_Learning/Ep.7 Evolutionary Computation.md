#DL 

## DNA Computing 
这是一种对于进化计算的尝试，试图将目前冯诺依曼架构的计算机改掉，使用 DNA 直接进行计算。这种方式有一些优点：极高的存储密度、强大的并行性能、极高的能量利用率
##### Example TSP 问题
![[Pasted image 20230508111938.png|400]]
- 首先，将城市用碱基编码
![[Pasted image 20230508112132.png|250]]
- 其次，将边进行编码，连接两个城市（就像引物设计一样）
![[Pasted image 20230508112224.png|350]]
- 最后，丢进去开始 PCR
![[Pasted image 20230508112410.png|400]]

## 进化计算
![[Pasted image 20230508114428.png|300]]
所有的进化计算算法的套路都是相同的：
![[Pasted image 20230508115153.png|500]]

- 表达：基因型还是表现型？
- 估价函数：就是目标函数
- 基因操作：交叉互换和变异
- 子代选择：根据适应度，进行随机的选择
- 探索和利用的平衡（重要）：选择机制是利用；交叉互换和突变是探索
- 初始化和终止：初始化可以随机；终止：到达目标答案/达到最大迭代/最大多样性/解的质量不上升
![[Pasted image 20230508121640.png|400]]

这样的算法是应用广泛的、无先验假设的、对噪声不敏感的、易于并行化执行的
算法的不足：无法得到证明、弱的理论基础、需要调节参数

## 常用的几种进化算法
![[Pasted image 20230515102131.png|400]]

- 基因组：所有候选解的公共表达形式。对于 GA 来说，基因组是一个二进制串（这可以证明算法的收敛性）
- 选择：基于归一化概率的选择
![[Pasted image 20230515102946.png|400]]

- 交叉和突变：需要按照一定的概率交叉突变

##### 一个实例：遗传地编程
这里面，我们试图将程序代码、数学或者逻辑表达式表示成树的形式，来找到最合适的某种表达。例如，我们希望使用很多个函数的组合来拟合一个新的函数，而不是采用神经网络。E.g.将数字放在叶结点上，而将运算符（算术、逻辑）放在非叶节点上；将运算符和语句放在非叶节点上，将变量和常量放在叶节点上。
![[Pasted image 20230515105350.png|250]]
在这个实例中，我们每次以 $1-p$ 的概率突变，而以 $p$ 的概率重组。突变率通常设置得较低。
- 本例中，突变：消去一颗子树；重组：交换两颗子树
- 一种选择方式：从前 80%中选择一部分，再从后 20%中选择一部分，这使得后代个体有被选择的可能
- 初始化方式：先指定深度，再填充非叶节点，最后将数字填充到叶结点上

##### 一个实例：函数回归
- 表达：+,-, $\times$,/ , $\sin$ , $\cos$
- 误差作为适应度

##### 进化规划
这里讲的是最简单的实码遗传算法，可以只突变、不重组。突变规则：每个个体分别突变
![[Pasted image 20230515112617.png|300]]
每一个个体都随机地加上以 0 为均值，以 $\sigma$ 为方差的数，并且，这个方差也在进化。

- Tournament Evolution：基于锦标赛的进化。找出每个个体，随机挑出几个对手进行比赛，按照获胜的次数进行排序。该算法中，每一个个体的对手是随机选择的，因此引入了随机性。

##### 实例：利用进化计算进行机器博弈
![[Pasted image 20230515120448.png|400]]
这里使用进化计算的目的是进化地调整神经网络中的参数










